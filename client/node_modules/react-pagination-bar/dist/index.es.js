import React, { useState, useEffect, useMemo } from 'react';

const Pagination = ({ onPageChange, currentPage = 1, totalItems, itemsPerPage = 10, startLabel = '<<', prevLabel = '<', nextLabel = '>', endLabel = '>>', pageNeighbours = 4, withProgressBar = false, onlyPageNumbers = false, withGoToInput = false, onlyPaginationButtons = false, customClassNames = {}, }) => {
    const classNames = (classes) => {
        return Object.entries(classes)
            .filter(([, value]) => value)
            .map(([key]) => key)
            .join(' ');
    };
    const [pagiState, setPagiState] = useState();
    const [goToInputValue, setGoToInputValue] = useState('');
    const styleClassName = {
        rpbRootClassName: customClassNames.rpbRootClassName || 'rpb-root',
        rpbItemClassName: customClassNames.rpbItemClassName || 'rpb-item',
        rpbItemClassNameActive: customClassNames.rpbItemClassNameActive || 'rpb-item--active',
        rpbItemClassNameDisable: customClassNames.rpbItemClassNameDisable || 'rpb-item--disabled',
        rpbProgressClassName: customClassNames.rpbProgressClassName || 'rpb-progress',
        rpbGoItemClassName: customClassNames.rpbGoItemClassName || 'rpb-go-item',
    };
    /**
     * Set new page when currentPage updates
     */
    useEffect(() => {
        setPage(currentPage);
    }, [currentPage]);
    const setPage = (page) => {
        // Disable clicking on a non-existent page
        if (page < 1 ||
            (pagiState && page > pagiState.totalPages) ||
            typeof page !== 'number' ||
            isNaN(page)) {
            return;
        }
        // Remove the first rendering, and also cancel the click on the active page
        if (page === currentPage) {
            return;
        }
        // Send current page outside component
        onPageChange(page);
    };
    const pagesList = useMemo(() => {
        const totalPages = Math.ceil(totalItems / itemsPerPage);
        let startPage;
        let endPage;
        if (totalPages <= pageNeighbours * 2 + 1) {
            startPage = 1;
            endPage = totalPages;
        }
        else {
            if (currentPage <= pageNeighbours) {
                startPage = 1;
                endPage = pageNeighbours * 2 + 1;
            }
            else if (currentPage + pageNeighbours >= totalPages) {
                startPage = totalPages - pageNeighbours * 2;
                endPage = totalPages;
            }
            else {
                startPage = currentPage - pageNeighbours;
                endPage = currentPage + pageNeighbours;
            }
        }
        return [...Array(endPage + 1 - startPage).keys()].map((i) => startPage + i);
    }, [totalItems, itemsPerPage, currentPage]);
    useEffect(() => {
        setPagiState({
            pages: pagesList,
            totalItems: totalItems,
            currentPage: currentPage,
            pagesLength: pagesList.length,
            totalPages: Math.ceil(totalItems / itemsPerPage), // all pages list length
        });
    }, [pagesList]);
    const onGoToPageSubmitHandle = () => {
        const value = Number(goToInputValue);
        if (pagiState) {
            if (value <= 0) {
                setPage(1);
            }
            else if (value > pagiState.totalPages) {
                setPage(pagiState.totalPages);
            }
            else {
                setPage(value);
            }
        }
    };
    if (pagiState && totalItems > itemsPerPage) {
        return (React.createElement("nav", { className: styleClassName.rpbRootClassName },
            React.createElement("ul", { id: "rpb-pagination", "aria-label": `Pagination Navigation, Current Page ${pagiState.currentPage}` },
                !onlyPageNumbers && (React.createElement(React.Fragment, null,
                    React.createElement("li", null,
                        React.createElement("button", { className: classNames({
                                [styleClassName.rpbItemClassName]: true,
                                [styleClassName.rpbItemClassNameDisable]: pagiState.currentPage === 1,
                            }), "aria-label": 'Go to first page', onClick: () => setPage(1) }, startLabel)),
                    React.createElement("li", null,
                        React.createElement("button", { className: classNames({
                                [styleClassName.rpbItemClassName]: true,
                                [styleClassName.rpbItemClassNameDisable]: pagiState.currentPage === 1,
                            }), "aria-label": 'Go to previous page', onClick: () => setPage(pagiState.currentPage - 1) }, prevLabel)))),
                !onlyPaginationButtons &&
                    pagiState.pages &&
                    pagiState.pages.map((mappedPage, index) => (React.createElement("li", { key: index },
                        React.createElement("button", { "aria-label": `Go to Page ${mappedPage}`, "aria-current": pagiState.currentPage === mappedPage, onClick: () => setPage(mappedPage), className: classNames({
                                [styleClassName.rpbItemClassName]: true,
                                [styleClassName.rpbItemClassNameActive]: pagiState.currentPage === mappedPage,
                            }) }, mappedPage)))),
                !onlyPageNumbers && (React.createElement(React.Fragment, null,
                    React.createElement("li", null,
                        React.createElement("button", { onClick: () => setPage(pagiState.currentPage + 1), "aria-label": "Go to next page", className: classNames({
                                [styleClassName.rpbItemClassName]: true,
                                [styleClassName.rpbItemClassNameDisable]: pagiState.currentPage === pagiState.totalPages,
                            }) }, nextLabel)),
                    React.createElement("li", null,
                        React.createElement("button", { className: classNames({
                                [styleClassName.rpbItemClassName]: true,
                                [styleClassName.rpbItemClassNameDisable]: pagiState.currentPage === pagiState.totalPages,
                            }), "aria-label": 'Go to last page', onClick: () => setPage(pagiState.totalPages) }, endLabel)))),
                withGoToInput && (React.createElement(React.Fragment, null,
                    React.createElement("li", null,
                        React.createElement("div", { className: styleClassName.rpbGoItemClassName },
                            React.createElement("input", { type: "number", onChange: (e) => setGoToInputValue(e.target.value) }))),
                    React.createElement("li", null,
                        React.createElement("button", { className: styleClassName.rpbItemClassName, onClick: onGoToPageSubmitHandle }, "Go"))))),
            withProgressBar && (React.createElement("div", { role: "progressbar", "aria-valuenow": pagiState.currentPage !== 1
                    ? Math.round((pagiState.currentPage / pagiState.totalPages) * 100)
                    : 0, "aria-valuemin": 0, "aria-valuemax": 100, "aria-labelledby": "rpb-pagination", className: styleClassName.rpbProgressClassName, style: {
                    width: pagiState.currentPage !== 1
                        ? Math.round((pagiState.currentPage / pagiState.totalPages) * 100) + '%'
                        : 0 + '%',
                } }))));
    }
    else {
        return null;
    }
};

export { Pagination };
//# sourceMappingURL=index.es.js.map
